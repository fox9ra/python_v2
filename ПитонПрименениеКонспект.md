# Python Примененние

### Links
http://pythontutor.com/visualize.html#mode=edit

***объекты*** - это представление данных в python (абстракция для данных), для неизменяемых если объекта в памяти нет то он создается, если есть то переиспользуется старый
***данные*** - это объекты и отношения к ним например есть:
переменная - в языке python - это всего лишь ссылка на объект

***
##		Модель данных
```
a=1
b=2
c=[a,b] - список
```
тогда в оперативной памяти объекты это 1 и 2,а с это объект с - это a и b и отношение к объектам 1 и 2

у любого объекта еть 3 преременных:

 - идентификатор - то что позволяет в любой момент времени отличить один объект от другого чтоб посмотреть есть функция **id()**. _ссылаются ли объекты на один и тот же идентификатор можно проверить с помощью оператора is_

 - тип - определяет то что можем сделать с объектом, определяет возможные принимаемы значения и его поведение, можно узнать с помощью **type()**

```
x=[1,2,3]
type(x) - #class 'list'
type(4) - #class 'int'
type(type(x)) - #class 'type'
```

 - значение - если в процессе жизни объект может изменить свое значен то он изменяем (mutable object), если не изменяем то (immutable)


####immutable:
 - *числа* - в контексте чисел можем изменить только ссылки на объекты справедливо для всех чисел int, float, complex
 - *bool* - логический тип имеет только 2 объекта True и False
 - *tuple* (кортеж) - неизменяемая последовательность и будучи один раз созданным неизменяется до конца жизни объекта
 - *str* (строки как последовательность символов) - хранятся символы в uniocode (utf8 default)
 - *frozenset* (неизменяемое множество)
 
####mutable: для всех изменяем типов будет создаваться новый объект:
- *list*(список) - значение списка это упорядоченное множество ссылок на объекты, можем например добавить ссылка на объект
- *dict* (словари) - можем изменить значение по ключу, добавить новую пару, или удаить ключ
- *set* (множество) - так же можем изменять

```
оператор присваивания:
x = 4 (имя = (что то) что то в любом случае будет объктом)
```

**иземеняется объект а не перепенная например:**
```python
x=[1,2,3]
y=x
print (y is x) #True
x.append(4)
print(x) #[1,2,3,4]
print(y) #[1,2,3,4]
#как видим изменили объект x т.к. y ссылается на тот же объет то изменился и y
```
***
##		Функции и стек вызовов

###_Функции используются для:_

- переиспользования части кода т.о. уменьшают код, исключение ошибок, 
- структурирование кода хорошая практика написание функций
- сокрытие деталей реализации позволяет не заморациваться думая как функция устроена внутри, достаточно понимать что делает

**определение функции начинается с def** (define - определить), отступ в 4 пробела в теле функции - важен т.к. это единственный знак интерпретатору который показывает что мы еще в теле функции, ___определение функции в python выполняется целиком___ т.е. сначала интерпритатор доходит до конца тела, и создает объект для функции в данном случае function_name будет ссылаться на объект созданый функцией
```python
type(function_name) #class 'function'
```
>при исполнении фунции сначала выполняется инициализация аргументов

### Стек вызовов, машинный стек
***Стек*** - абстрактная структура данных
*push* - операция положить элемент на стек
*pop* - забрать элемент из стека

> Стек можно сравнить с детской пирамидкой

Стек вызов отборажает все функции которые исполняются в данный момент, и кто кого ждет

**пример со стеком:**
```python
x=[1,2,3]

x.append(4)
x.append(5)

print(x) #[1, 2, 3, 4, 5]

top=x.pop() # top() за
print(top) #5 
print(x)  #[1, 2, 3, 4]

top=x.pop()
print(top) #4
print(x) #[1, 2, 3]
#после методов append и pop данный список ведет себя так же как и стек
```

>для возвращения значения используется return, после return функция дальше не выполняется. в функции не обязательно что то возвращать если используется пустой return или его вообще нет то вернется None - это объект

---
***передача аргументов внутрь функции:***

- ```printab(10,20)``` - позиционное
- ```printab(a=10,b=20)``` - именованое
- ```printab(10,b=20)``` - совмещенное, в данном случае сначала надо передовать позиционные элементы, а потом именованые

***из списка:***
```
lst=[10,20]
printab[*lst] #равносильно printab(lst[0],lst[1])
```
***из словаря:***
```
args={'a':10, 'b':20}
printab(**args) #две звездочки равносильно ключ значение printab(key1=args[key1], key2=args[key2]) т.е. a=10,b=20
```

>для передачи в функцию неопределенное число позиционных элементов используется * которая создает кортеж например def printab(a, b, *args) в этом случае это кортеж args=() и они ровно в том порядке в котором переданы

>для именованных неопределенное число элементов используется ** при инициализации помезаются в словарь например def printab(a, b, **kwargs) в этом случае при вызове printab(10, 20, c=30, d=40 ,jimmi=123) kwargs={'c':30, 'd':40, 'jimmi':123}

***можно объединять передачу агрументов порядок следующий:***

```python
def function_name([pozitional_args,
				  [pozitional_args_with_default,
				  [*pos_args_name,
				  [keyword_only_args,
				  [**kw_agrs_name]]]]]]):
```

_пример:_

```python
def printab(a,b=10,*args,c=10,d,**kwargs):
	print(a,b,c,d)
printab(15,d=15)
```

***рекурсивные функции*** - функции которые внутри себя вызывают самих себя пример вычисление числа фибоначи

```python
def fix(x)
	if x == 0 or x == 1:
		return 1
	else:
		return fib(x-1) + fix(x-2)
```

##		Пространсва имен

множество ссылок переменных(имен) на объекты и называем ***пространство имен***

- **первое** пространство которое создается это **builtins** оно создается когда запускаем интерпритатор и содержит в себе **встроенные функции и классы**:
builtins:
	int, str, float, bool ... - типы
	max, abs, id ... встроенные функции
	
- **второе** пространство это **main** содержит те имена которые мы объявили **в самом верху нашего кода**:
```python
	a=1
	def fun():
		x=1
#здесь в main попадет a и fun, x не попадет т.к. тело функции не исполняется когда функцию определяем
```
- **локальные** переменные которые создаются внутри функции **после выполнения функции удаляются**

***область видимости*** - это текстовые фрагменты в которых namespace доступны напрямую, области видимости статичны. верно правило LEGB (Local scope, Enclosing Scope, Global Scope, Builtins Scope)

>Условные операторы и циклы не создают локальных пространств имен

Иногда нужно изменить глобальную переменную или не входящую в локальну переменную для этого есть **global** и **nonlocal**

_пример:_
```python
ok_status=True
def check(word):
	global ok_status #это конструкция означает что взять имя ok_status из глобального namespace и его и использовать
```
**nonlocal** - идет по namespace и ищет переменную с таким именем в ближайщем space, если не нашел идет дальше, в итоге ищет не в локальном и не в глобальном а в промежутке

##		Классы

**Классы** 

- позволяют описать поведение объектов данного класса
- Механизем и синтаксис для определения объектов 
- Классы исполняются в момент определения самого класса, так же как и функции создается свой namespace

для классов гарантируется всего две вещи:

1. можем из него вызвать контруктор MyClass()
2. можем обращаться к его аттрибутам MyClass.a

>Есть объекты классы и объекты экземпляров 
>>Экземпляры имеют тип класса который создаем, контструктор позволяет создавать экземпляры у объектов классов и у объектов экземпляров есть свое пространство имен. Аттрибуты в этом пространсве имен можем изменять и можем создавать.

>Исполнение контруктора класса начинается в момент создания каждого экземпляра класса

### Наследование классов
например наследуемся от list стандартного python, у него будет новый метод который проверят является длинна списка четной
```python
class MyList(list):
	def even_length(self):
		return len(self) % 2 ==0

x = MyList()
print(x) #[]
x.extend([1,2,3,4,5])
print(x) #[1,2,3,4,5]
print(x.even_length()) #False
x.append(6)
print(x.even_length()) #True
```

**Множественное наследование** - когда создаем класс можем выбрать несколько классов от которого будем наследоваться. 
>Для проверки является класс наследником другого класса используется функция **issubclass**

>Также есть функция **isinstance** которая отвечает на вопрос является ли переменная первого типа наследником второго аргумента.

пример:
```python
class D: pass
class E: pass
class B(D, E): pass
class C: pass
class A(B, C): pass

issubclass(A, A) #True
issubclass(C, D) #False
issubclass(A, D) #True
issubclass(C, object) #True
issubclass(object, C) #False

x = A()
isinstance(x, A) #True
isinstance(x, B) #True
isinstance(x, object) #True
isinstance(x, str) #False
```

>при множественном наследовании, если класс наследуется не от одного класса а от нескольких, то в порядок поиска функиции можно определить вывовом *mro*

Порядок разрешения методов.
```python
class D: pass
class E: pass
class B(D, E): pass
class C: pass
class A(B, C): pass

print(A.mro())

#[<class '__main__.A'>, <class '__main__.B'>, 
#<class '__main__.D'>, <class '__main__.E'>, 
#<class '__main__.C'>, <class 'object'>]
```

>переборка родителей идет в том же порядке в котором объявляется